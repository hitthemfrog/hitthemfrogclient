{"version":3,"sources":["../node_modules/three/examples/js/loaders/GLTFLoader.js"],"names":["THREE","GLTFLoader","manager","this","undefined","DefaultLoadingManager","dracoLoader","ddsLoader","GLTFRegistry","objects","get","key","add","object","remove","removeAll","prototype","constructor","crossOrigin","load","url","onLoad","onProgress","onError","resourcePath","scope","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setWithCredentials","data","parse","gltf","setCrossOrigin","value","setResourcePath","setDRACOLoader","setDDSLoader","content","extensions","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","asset","version","Error","extensionsUsed","i","length","extensionName","extensionsRequired","KHR_LIGHTS_PUNCTUAL","GLTFLightsExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","indexOf","warn","GLTFParser","name","extension","lightDefs","lights","loadLight","lightIndex","lightNode","lightDef","color","Color","fromArray","range","type","DirectionalLight","target","position","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","Promise","resolve","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","parser","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","push","assignTexture","all","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","magic","slice","getUint32","chunkView","chunkIndex","byteLength","chunkLength","chunkType","contentArray","byteOffset","specularGlossinessParams","ShaderMaterial","pbrSpecularGlossiness","shader","ShaderLib","uniforms","UniformsUtils","clone","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","fragmentShader","replace","roughness","metalness","roughnessMap","metalnessMap","specular","setHex","glossiness","specularMap","glossinessMap","vertexShader","defines","STANDARD","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","params","material","fog","transparent","isGLTFSpecularGlossinessMaterial","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","derivatives","cloneMaterial","source","il","isColor","refreshUniforms","renderer","scene","camera","geometry","uvScaleMap","diffuse","copy","multiplyScalar","isWebGLRenderTarget","texture","matrixAutoUpdate","updateMatrix","uvTransform","matrix","flipEnvMap","isCubeTexture","reflectivity","maxMipLevel","properties","__maxMipLevel","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","Interpolant","call","decodePrimitive","primitive","bufferViewIndex","bufferView","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","getDependency","then","decodeDracoFile","attribute","extendTexture","transform","offset","rotation","scale","repeat","texCoord","needsUpdate","Object","create","copySampleValue_","index","result","values","valueSize","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","defaultMaterial","WEBGL_CONSTANTS","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","NearestFilter","9729","LinearFilter","9984","NearestMipMapNearestFilter","9985","LinearMipMapNearestFilter","9986","NearestMipMapLinearFilter","9987","LinearMipMapLinearFilter","WEBGL_WRAPPINGS","33071","ClampToEdgeWrapping","33648","MirroredRepeatWrapping","10497","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","MIME_TYPE_FORMATS","image/png","RGBAFormat","image/jpeg","RGBFormat","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","assign","updateMorphTargets","mesh","meshDef","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","indices","createAttributesKey","mode","attributesKey","keys","sort","cloneBufferAttribute","isInterleavedBufferAttribute","count","itemSize","j","getX","getY","getZ","getW","BufferAttribute","options","cache","primitiveCache","textureLoader","TextureLoader","fileLoader","addPrimitiveAttributes","assignAttributeAccessor","accessorIndex","accessor","addAttribute","gltfAttributeName","setIndex","targets","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","normal","morphPositions","morphNormals","positionAttribute","jl","setXYZ","normalAttribute","morphAttributes","addMorphTargets","markDefs","getDependencies","dependencies","scenes","animations","cameras","catch","nodeDefs","nodes","skinDefs","skins","meshDefs","meshes","meshReferences","meshUses","skinIndex","skinLength","joints","isBone","nodeIndex","nodeLength","nodeDef","skin","isSkinnedMesh","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadTexture","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","uri","reject","bufferViewDef","bufferViews","buffer","sparse","pendingBufferViews","bufferAttribute","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","byteStride","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setArray","setX","setY","setZ","setW","textureIndex","URL","window","webkitURL","textureDef","textures","textureExtensions","sourceURI","images","isObjectURL","blob","Blob","mimeType","createObjectURL","Loader","Handlers","revokeObjectURL","flipY","format","sampler","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","isCompressedTexture","assignFinalMaterial","useVertexTangents","tangent","useVertexColors","useFlatShading","useSkinning","useMorphTargets","useMorphNormals","isPoints","uuid","pointsMaterial","PointsMaterial","Material","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","skinning","vertexTangents","vertexColors","VertexColors","flatShading","morphTargets","uv2","uv","log","onBeforeRender","materialIndex","materialType","materials","materialExtensions","sgExtension","kmuExtension","MeshStandardMaterial","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","alphaTest","alphaCutoff","normalTexture","Vector2","occlusionTexture","strength","emissiveFactor","emissiveTexture","encoding","sRGBEncoding","loadGeometries","primitives","createDracoPrimitive","geometryPromise","cached","promise","BufferGeometry","meshIndex","depthTest","FrontSide","originalMaterials","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","drawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","cameraDef","PerspectiveCamera","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","Bone","instanceNum","children","o","light","Object3D","PropertyBinding","sanitizeNodeName","Matrix4","applyMatrix","quaternion","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","isGroup","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","child","sceneIndex","sceneDef","Scene","nodeIds"],"mappings":"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","file":"static/js/3.37856bc8.chunk.js","sourcesContent":["/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\nTHREE.GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n    this.dracoLoader = null;\n    this.ddsLoader = null;\n  }\n\n  GLTFLoader.prototype = {\n    constructor: GLTFLoader,\n    crossOrigin: 'anonymous',\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== undefined) {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== undefined) {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n\n      if (scope.crossOrigin === 'use-credentials') {\n        loader.setWithCredentials(true);\n      }\n\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setCrossOrigin: function setCrossOrigin(value) {\n      this.crossOrigin = value;\n      return this;\n    },\n    setPath: function setPath(value) {\n      this.path = value;\n      return this;\n    },\n    setResourcePath: function setResourcePath(value) {\n      this.resourcePath = value;\n      return this;\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    setDDSLoader: function setDDSLoader(ddsLoader) {\n      this.ddsLoader = ddsLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension(this.ddsLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] = new GLTFTextureTransformExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  };\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification:\n   * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension(ddsLoader) {\n    if (!ddsLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = ddsLoader;\n  }\n  /**\n   * Lights Extension\n   *\n   * Specification: PENDING\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new THREE.Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new THREE.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new THREE.PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new THREE.SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension (pending)\n   *\n   * PR: https://github.com/KhronosGroup/glTF/pull/1163\n   */\n\n\n  function GLTFMaterialsUnlitExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n    return THREE.MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = THREE.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/pull/874\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification:\n   */\n\n\n  function GLTFTextureTransformExtension() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return THREE.ShaderMaterial;\n      },\n      extendParams: function extendParams(materialParams, materialDef, parser) {\n        var pbrSpecularGlossiness = materialDef.extensions[this.name];\n        var shader = THREE.ShaderLib['standard'];\n        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new THREE.Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        materialParams.vertexShader = shader.vertexShader;\n        materialParams.fragmentShader = fragmentShader;\n        materialParams.uniforms = uniforms;\n        materialParams.defines = {\n          'STANDARD': ''\n        };\n        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new THREE.ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {THREE.ShaderMaterial} source\n       * @return {THREE.ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          var value = source[params[i]];\n          target[params[i]] = value && value.isColor ? value.clone() : value;\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          if (uvScaleMap.matrixAutoUpdate === true) {\n            uvScaleMap.updateMatrix();\n          }\n\n          uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n        }\n\n        if (material.envMap) {\n          uniforms.envMap.value = material.envMap;\n          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:\n          //  WebGLRenderTargetCube will be flipped for backwards compatibility\n          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\n          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\n          uniforms.reflectivity.value = material.reflectivity;\n          uniforms.refractionRatio.value = material.refractionRatio;\n          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n        }\n\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n    var s0 = 1 - s2;\n    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipMapNearestFilter,\n    9985: THREE.LinearMipMapNearestFilter,\n    9986: THREE.NearestMipMapLinearFilter,\n    9987: THREE.LinearMipMapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': THREE.RGBAFormat,\n    'image/jpeg': THREE.RGBFormat\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n\n  var defaultMaterial;\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n  function createDefaultMaterial() {\n    defaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n    return defaultMaterial;\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (typeof gltfDef.extras === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1]; // Clone morph target accessors before modifying them.\n\n      for (var i = 0, il = morphPositions.length; i < il; i++) {\n        if (geometry.attributes.position === morphPositions[i]) continue;\n        morphPositions[i] = cloneBufferAttribute(morphPositions[i]);\n      }\n\n      for (var i = 0, il = morphNormals.length; i < il; i++) {\n        if (geometry.attributes.normal === morphNormals[i]) continue;\n        morphNormals[i] = cloneBufferAttribute(morphNormals[i]);\n      }\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n        var attributeName = 'morphTarget' + i;\n\n        if (hasMorphPosition) {\n          // Three.js morph position is absolute value. The formula is\n          //   basePosition\n          //     + weight0 * ( morphPosition0 - basePosition )\n          //     + weight1 * ( morphPosition1 - basePosition )\n          //     ...\n          // while the glTF one is relative\n          //   basePosition\n          //     + weight0 * glTFmorphPosition0\n          //     + weight1 * glTFmorphPosition1\n          //     ...\n          // then we need to convert from relative to absolute here.\n          if (target.POSITION !== undefined) {\n            var positionAttribute = morphPositions[i];\n            positionAttribute.name = attributeName;\n            var position = geometry.attributes.position;\n\n            for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n              positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n            }\n          }\n        }\n\n        if (hasMorphNormal) {\n          // see target.POSITION's comment\n          if (target.NORMAL !== undefined) {\n            var normalAttribute = morphNormals[i];\n            normalAttribute.name = attributeName;\n            var normal = geometry.attributes.normal;\n\n            for (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n              normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n            }\n          }\n        }\n      }\n\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      return geometry;\n    });\n  }\n  /**\n   * @param {THREE.Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n\n  function cloneBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) {\n      var count = attribute.count;\n      var itemSize = attribute.itemSize;\n      var array = attribute.array.slice(0, count * itemSize);\n\n      for (var i = 0, j = 0; i < count; ++i) {\n        array[j++] = attribute.getX(i);\n        if (itemSize >= 2) array[j++] = attribute.getY(i);\n        if (itemSize >= 3) array[j++] = attribute.getZ(i);\n        if (itemSize >= 4) array[j++] = attribute.getW(i);\n      }\n\n      return new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n    }\n\n    return attribute.clone();\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new THREE.TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new THREE.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      onLoad(result);\n    }).catch(onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one THREE.Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          // Use the full buffer if it's interleaved.\n          array = new TypedArray(bufferView); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute.setArray(bufferAttribute.array.slice());\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = THREE.Loader.Handlers.get(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture.isCompressedTexture) {\n        switch (mapName) {\n          case 'aoMap':\n          case 'emissiveMap':\n          case 'metalnessMap':\n          case 'normalMap':\n          case 'roughnessMap':\n            texture.format = THREE.RGBFormat;\n            break;\n        }\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var extensions = this.extensions;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new THREE.PointsMaterial();\n        THREE.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new THREE.LineBasicMaterial();\n        THREE.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n      geometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n\n    if (material.isGLTFSpecularGlossinessMaterial) {\n      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<THREE.Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = THREE.MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = THREE.DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new THREE.Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === THREE.ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = THREE.sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n      if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {THREE.BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<THREE.BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.addAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<THREE.BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    return Promise.all(pending).then(function (originalMaterials) {\n      return parser.loadGeometries(primitives).then(function (geometries) {\n        var meshes = [];\n\n        for (var i = 0, il = geometries.length; i < il; i++) {\n          var geometry = geometries[i];\n          var primitive = primitives[i]; // 1. create Mesh\n\n          var mesh;\n          var material = originalMaterials[i];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\n\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n              mesh.normalizeSkinWeights();\n            }\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.drawMode = THREE.TriangleStripDrawMode;\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.drawMode = THREE.TriangleFanDrawMode;\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new THREE.LineSegments(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new THREE.Line(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new THREE.LineLoop(geometry, material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new THREE.Points(geometry, material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n\n          mesh.name = meshDef.name || 'mesh_' + meshIndex;\n          if (geometries.length > 1) mesh.name += '_' + i;\n          assignExtrasToUserData(mesh, meshDef);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n\n        var group = new THREE.Group();\n\n        for (var i = 0, il = meshes.length; i < il; i++) {\n          group.add(meshes[i]);\n        }\n\n        return group;\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<THREE.AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        var outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          var scale;\n\n          if (outputArray.constructor === Int8Array) {\n            scale = 1 / 127;\n          } else if (outputArray.constructor === Uint8Array) {\n            scale = 1 / 255;\n          } else if (outputArray.constructor == Int16Array) {\n            scale = 1 / 32767;\n          } else if (outputArray.constructor === Uint16Array) {\n            scale = 1 / 65535;\n          } else {\n            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n          }\n\n          var scaled = new Float32Array(outputArray.length);\n\n          for (var j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new THREE.AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<THREE.Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      // .isBone isn't in glTF spec. See .markDefs\n      if (nodeDef.isBone === true) {\n        return Promise.resolve(new THREE.Bone());\n      } else if (nodeDef.mesh !== undefined) {\n        return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness\n\n            node.onBeforeRender = mesh.onBeforeRender;\n\n            for (var i = 0, il = node.children.length; i < il; i++) {\n              node.children[i].name += '_instance_' + instanceNum;\n              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n            }\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        });\n      } else if (nodeDef.camera !== undefined) {\n        return parser.getDependency('camera', nodeDef.camera);\n      } else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        return parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);\n      } else {\n        return Promise.resolve(new THREE.Object3D());\n      }\n    }().then(function (node) {\n      if (nodeDef.name !== undefined) {\n        node.userData.name = nodeDef.name;\n        node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new THREE.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<THREE.Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          var meshes = node.isGroup === true ? node.children : [node];\n\n          for (var i = 0, il = meshes.length; i < il; i++) {\n            var mesh = meshes[i];\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new THREE.Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n          }\n\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this;\n      var scene = new THREE.Scene();\n      if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();"],"sourceRoot":""}